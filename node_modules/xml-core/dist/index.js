(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.XmlCore = {})));
}(this, (function (exports) { 'use strict';

function __extends(d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var ELEMENT = "element";
var ATTRIBUTE = "attribute";
var CONTENT = "content";

var MAX = 1e9;
function assign(target) {
    var sources = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        sources[_i - 1] = arguments[_i];
    }
    var res = arguments[0];
    for (var i = 1; i < arguments.length; i++) {
        var obj = arguments[i];
        for (var prop in obj) {
            if (!obj.hasOwnProperty(prop)) {
                continue;
            }
            res[prop] = obj[prop];
        }
    }
    return res;
}
function XmlElement(params) {
    return function (target) {
        var t = target;
        t.localName = params.localName || t.name;
        t.namespaceURI = params.namespaceURI || t.namespaceURI || null;
        t.prefix = params.prefix || t.prefix || null;
        t.parser = params.parser || t.parser;
        if (t.target !== t) {
            t.items = assign({}, t.items);
        }
        t.target = target;
    };
}
function XmlChildElement(params) {
    if (params === void 0) { params = {}; }
    return function (target, propertyKey) {
        var t = target.constructor;
        var key = propertyKey;
        if (!t.items) {
            t.items = {};
        }
        if (t.target !== t) {
            t.items = assign({}, t.items);
        }
        t.target = target;
        if (params.parser) {
            t.items[key] = {
                parser: params.parser,
                required: params.required || false,
                maxOccurs: params.maxOccurs || MAX,
                minOccurs: params.minOccurs === void 0 ? 0 : params.minOccurs,
                noRoot: params.noRoot || false,
            };
        }
        else {
            t.items[key] = {
                namespaceURI: params.namespaceURI || null,
                required: params.required || false,
                prefix: params.prefix || null,
                defaultValue: params.defaultValue,
                converter: params.converter,
            };
        }
        params.localName = params.localName || (params.parser && params.parser.localName) || key;
        t.items[key].namespaceURI = params.namespaceURI || (params.parser && params.parser.namespaceURI) || null;
        t.items[key].prefix = params.prefix || (params.parser && params.parser.prefix) || null;
        t.items[key].localName = params.localName;
        t.items[key].type = ELEMENT;
        defineProperty(target, key, params);
    };
}
function XmlAttribute(params) {
    if (params === void 0) { params = { required: false, namespaceURI: null }; }
    return function (target, propertyKey) {
        var t = target.constructor;
        var key = propertyKey;
        if (!params.localName) {
            params.localName = propertyKey;
        }
        if (!t.items) {
            t.items = {};
        }
        if (t.target !== t) {
            t.items = assign({}, t.items);
        }
        t.target = target;
        t.items[propertyKey] = params;
        t.items[propertyKey].type = ATTRIBUTE;
        defineProperty(target, key, params);
    };
}
function XmlContent(params) {
    if (params === void 0) { params = { required: false }; }
    return function (target, propertyKey) {
        var t = target.constructor;
        var key = propertyKey;
        if (!t.items) {
            t.items = {};
        }
        if (t.target !== t) {
            t.items = assign({}, t.items);
        }
        t.target = target;
        t.items[propertyKey] = params;
        t.items[propertyKey].type = CONTENT;
        defineProperty(target, key, params);
    };
}
function defineProperty(target, key, params) {
    var key2 = "_" + key;
    var opt = {
        set: function (v) {
            if (this[key2] !== v) {
                this.element = null;
                this[key2] = v;
            }
        },
        get: function () {
            if (this[key2] === void 0) {
                var defaultValue = params.defaultValue;
                if (params.parser) {
                    defaultValue = new params.parser();
                    defaultValue.localName = params.localName;
                }
                this[key2] = defaultValue;
            }
            return this[key2];
        },
    };
    Object.defineProperty(target, key2, { writable: true, enumerable: false });
    Object.defineProperty(target, key, opt);
}

var Collection = (function () {
    function Collection(items) {
        this.items = new Array();
        if (items) {
            this.items = items;
        }
    }
    Object.defineProperty(Collection.prototype, "Count", {
        get: function () {
            return this.items.length;
        },
        enumerable: true,
        configurable: true
    });
    Collection.prototype.Item = function (index) {
        return this.items[index] || null;
    };
    Collection.prototype.Add = function (item) {
        this.items.push(item);
    };
    Collection.prototype.Pop = function () {
        return this.items.pop();
    };
    Collection.prototype.RemoveAt = function (index) {
        this.items = this.items.filter(function (item, index2) { return index2 !== index; });
    };
    Collection.prototype.Clear = function () {
        this.items = new Array();
    };
    Collection.prototype.GetIterator = function () {
        return this.items;
    };
    Collection.prototype.ForEach = function (cb) {
        this.GetIterator().forEach(cb);
    };
    Collection.prototype.Map = function (cb) {
        return new Collection(this.GetIterator().map(cb));
    };
    Collection.prototype.Filter = function (cb) {
        return new Collection(this.GetIterator().filter(cb));
    };
    Collection.prototype.Sort = function (cb) {
        return new Collection(this.GetIterator().sort(cb));
    };
    Collection.prototype.Every = function (cb) {
        return this.GetIterator().every(cb);
    };
    Collection.prototype.Some = function (cb) {
        return this.GetIterator().some(cb);
    };
    Collection.prototype.IsEmpty = function () {
        return this.Count === 0;
    };
    return Collection;
}());

function printf(text) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    var msg = text;
    var regFind = /[^%](%\d+)/g;
    var match = null;
    var matches = [];
    while (match = regFind.exec(msg)) {
        matches.push({ arg: match[1], index: match.index });
    }
    for (var i = matches.length - 1; i >= 0; i--) {
        var item = matches[i];
        var arg = item.arg.substring(1);
        var index = item.index + 1;
        msg = msg.substring(0, index) + arguments[+arg] + msg.substring(index + 1 + arg.length);
    }
    msg = msg.replace("%%", "%");
    return msg;
}
function padNum(num, size) {
    var s = num + "";
    while (s.length < size) {
        s = "0" + s;
    }
    return s;
}
var XmlError = (function () {
    function XmlError(code) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        this.prefix = "XMLJS";
        this.code = code;
        this.name = this.constructor.name;
        arguments[0] = xes[code];
        var message = printf.apply(this, arguments);
        this.message = "" + this.prefix + padNum(code, 4) + ": " + message;
        this.stack = new Error(this.message).stack;
    }
    return XmlError;
}());

(function (XE) {
    XE[XE["NONE"] = 0] = "NONE";
    XE[XE["NULL_REFERENCE"] = 1] = "NULL_REFERENCE";
    XE[XE["NULL_PARAM"] = 2] = "NULL_PARAM";
    XE[XE["DECORATOR_NULL_PARAM"] = 3] = "DECORATOR_NULL_PARAM";
    XE[XE["COLLECTION_LIMIT"] = 4] = "COLLECTION_LIMIT";
    XE[XE["METHOD_NOT_IMPLEMENTED"] = 5] = "METHOD_NOT_IMPLEMENTED";
    XE[XE["METHOD_NOT_SUPPORTED"] = 6] = "METHOD_NOT_SUPPORTED";
    XE[XE["PARAM_REQUIRED"] = 7] = "PARAM_REQUIRED";
    XE[XE["CONVERTER_UNSUPPORTED"] = 8] = "CONVERTER_UNSUPPORTED";
    XE[XE["ELEMENT_MALFORMED"] = 9] = "ELEMENT_MALFORMED";
    XE[XE["ELEMENT_MISSING"] = 10] = "ELEMENT_MISSING";
    XE[XE["ATTRIBUTE_MISSING"] = 11] = "ATTRIBUTE_MISSING";
    XE[XE["CONTENT_MISSING"] = 12] = "CONTENT_MISSING";
    XE[XE["CRYPTOGRAPHIC"] = 13] = "CRYPTOGRAPHIC";
    XE[XE["CRYPTOGRAPHIC_NO_MODULE"] = 14] = "CRYPTOGRAPHIC_NO_MODULE";
    XE[XE["CRYPTOGRAPHIC_UNKNOWN_TRANSFORM"] = 15] = "CRYPTOGRAPHIC_UNKNOWN_TRANSFORM";
    XE[XE["ALGORITHM_NOT_SUPPORTED"] = 16] = "ALGORITHM_NOT_SUPPORTED";
    XE[XE["ALGORITHM_WRONG_NAME"] = 17] = "ALGORITHM_WRONG_NAME";
    XE[XE["XML_EXCEPTION"] = 18] = "XML_EXCEPTION";
})(exports.XE || (exports.XE = {}));
var xes = {};
xes[exports.XE.NONE] = "No decription";
xes[exports.XE.NULL_REFERENCE] = "Null reference";
xes[exports.XE.NULL_PARAM] = "'%1' has empty '%2' object";
xes[exports.XE.DECORATOR_NULL_PARAM] = "Decorator '%1' has empty '%2' parameter";
xes[exports.XE.COLLECTION_LIMIT] = "Collection of '%1' in element '%2' has wrong amount of items";
xes[exports.XE.METHOD_NOT_IMPLEMENTED] = "Method is not implemented";
xes[exports.XE.METHOD_NOT_SUPPORTED] = "Method is not supported";
xes[exports.XE.PARAM_REQUIRED] = "Required parameter is missing '%1'";
xes[exports.XE.CONVERTER_UNSUPPORTED] = "Converter is not supported";
xes[exports.XE.ELEMENT_MALFORMED] = "Malformed element '%1'";
xes[exports.XE.ELEMENT_MISSING] = "Element '%1' is missing in '%2'";
xes[exports.XE.ATTRIBUTE_MISSING] = "Attribute '%1' is missing in '%2'";
xes[exports.XE.CONTENT_MISSING] = "Content is missing in '%1'";
xes[exports.XE.CRYPTOGRAPHIC] = "Cryptographic error: %1";
xes[exports.XE.CRYPTOGRAPHIC_NO_MODULE] = "WebCrypto module is not found";
xes[exports.XE.CRYPTOGRAPHIC_UNKNOWN_TRANSFORM] = "Unknown transform %1";
xes[exports.XE.ALGORITHM_NOT_SUPPORTED] = "Algorithm is not supported '%1'";
xes[exports.XE.ALGORITHM_WRONG_NAME] = "Algorithm wrong name in use '%1'";
xes[exports.XE.XML_EXCEPTION] = "XML exception: %1";

var Convert = (function () {
    function Convert() {
    }
    Convert.ToString = function (buffer, enc) {
        if (enc === void 0) { enc = "utf8"; }
        var buf = new Uint8Array(buffer);
        switch (enc.toLowerCase()) {
            case "utf8":
                return this.ToUtf8String(buf);
            case "binary":
                return this.ToBinary(buf);
            case "hex":
                return this.ToHex(buf);
            case "base64":
                return this.ToBase64(buf);
            case "base64url":
                return this.ToBase64Url(buf);
            default:
                throw new XmlError(exports.XE.CONVERTER_UNSUPPORTED);
        }
    };
    Convert.FromString = function (str, enc) {
        if (enc === void 0) { enc = "utf8"; }
        switch (enc.toLowerCase()) {
            case "utf8":
                return this.FromUtf8String(str);
            case "binary":
                return this.FromBinary(str);
            case "hex":
                return this.FromHex(str);
            case "base64":
                return this.FromBase64(str);
            case "base64url":
                return this.FromBase64Url(str);
            default:
                throw new XmlError(exports.XE.CONVERTER_UNSUPPORTED);
        }
    };
    Convert.ToBase64 = function (buf) {
        if (typeof btoa !== "undefined") {
            var binary = this.ToString(buf, "binary");
            return btoa(binary);
        }
        else if (typeof Buffer !== "undefined") {
            return new Buffer(buf).toString("base64");
        }
        else {
            throw new XmlError(exports.XE.CONVERTER_UNSUPPORTED);
        }
    };
    Convert.FromBase64 = function (base64Text) {
        base64Text = base64Text.replace(/\n/g, "").replace(/\r/g, "").replace(/\t/g, "").replace(/\s/g, "");
        if (typeof atob !== "undefined") {
            return this.FromBinary(atob(base64Text));
        }
        else if (typeof Buffer !== "undefined") {
            return new Buffer(base64Text, "base64");
        }
        else {
            throw new XmlError(exports.XE.CONVERTER_UNSUPPORTED);
        }
    };
    Convert.FromBase64Url = function (base64url) {
        return this.FromBase64(this.Base64Padding(base64url.replace(/\-/g, "+").replace(/\_/g, "/")));
    };
    Convert.ToBase64Url = function (data) {
        return this.ToBase64(data).replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
    };
    Convert.FromUtf8String = function (text) {
        var s = unescape(encodeURIComponent(text));
        var uintArray = new Uint8Array(s.length);
        for (var i = 0; i < s.length; i++) {
            uintArray[i] = s.charCodeAt(i);
        }
        return uintArray;
    };
    Convert.ToUtf8String = function (buffer) {
        var encodedString = String.fromCharCode.apply(null, buffer);
        var decodedString = decodeURIComponent(escape(encodedString));
        return decodedString;
    };
    Convert.FromBinary = function (text) {
        var stringLength = text.length;
        var resultView = new Uint8Array(stringLength);
        for (var i = 0; i < stringLength; i++) {
            resultView[i] = text.charCodeAt(i);
        }
        return resultView;
    };
    Convert.ToBinary = function (buffer) {
        var resultString = "";
        for (var i = 0; i < buffer.length; i++) {
            resultString = resultString + String.fromCharCode(buffer[i]);
        }
        return resultString;
    };
    Convert.ToHex = function (buffer) {
        var splitter = "";
        var res = [];
        for (var i = 0; i < buffer.length; i++) {
            var char = buffer[i].toString(16);
            res.push(char.length === 1 ? "0" + char : char);
        }
        return res.join(splitter);
    };
    Convert.FromHex = function (hexString) {
        var res = new Uint8Array(hexString.length / 2);
        for (var i = 0; i < hexString.length; i = i + 2) {
            var c = hexString.slice(i, i + 2);
            res[i / 2] = parseInt(c, 16);
        }
        return res;
    };
    Convert.ToDateTime = function (dateTime) {
        return new Date(dateTime);
    };
    Convert.FromDateTime = function (dateTime) {
        var str = dateTime.toISOString();
        return str;
    };
    Convert.Base64Padding = function (base64) {
        var padCount = 4 - (base64.length % 4);
        if (padCount < 4) {
            for (var i = 0; i < padCount; i++) {
                base64 += "=";
            }
        }
        return base64;
    };
    return Convert;
}());

var APPLICATION_XML = "application/xml";
var DEFAULT_PREFIX = "";
var DEFAULT_NAMESPACE_URI = "";

(function (XmlNodeType) {
    XmlNodeType[XmlNodeType["None"] = 0] = "None";
    XmlNodeType[XmlNodeType["Element"] = 1] = "Element";
    XmlNodeType[XmlNodeType["Attribute"] = 2] = "Attribute";
    XmlNodeType[XmlNodeType["Text"] = 3] = "Text";
    XmlNodeType[XmlNodeType["CDATA"] = 4] = "CDATA";
    XmlNodeType[XmlNodeType["EntityReference"] = 5] = "EntityReference";
    XmlNodeType[XmlNodeType["Entity"] = 6] = "Entity";
    XmlNodeType[XmlNodeType["ProcessingInstruction"] = 7] = "ProcessingInstruction";
    XmlNodeType[XmlNodeType["Comment"] = 8] = "Comment";
    XmlNodeType[XmlNodeType["Document"] = 9] = "Document";
    XmlNodeType[XmlNodeType["DocumentType"] = 10] = "DocumentType";
    XmlNodeType[XmlNodeType["DocumentFragment"] = 11] = "DocumentFragment";
    XmlNodeType[XmlNodeType["Notation"] = 12] = "Notation";
    XmlNodeType[XmlNodeType["Whitespace"] = 13] = "Whitespace";
    XmlNodeType[XmlNodeType["SignificantWhitespace"] = 14] = "SignificantWhitespace";
    XmlNodeType[XmlNodeType["EndElement"] = 15] = "EndElement";
    XmlNodeType[XmlNodeType["EndEntity"] = 16] = "EndEntity";
    XmlNodeType[XmlNodeType["XmlDeclaration"] = 17] = "XmlDeclaration";
})(exports.XmlNodeType || (exports.XmlNodeType = {}));

var xpath = function (node, xPath) {
    throw new Error("Not implemented");
};
var sWindow;
if (typeof self === "undefined") {
    sWindow = global;
    var xmldom = require("xmldom-alpha");
    xpath = require("xpath.js");
    sWindow.XMLSerializer = xmldom.XMLSerializer;
    sWindow.DOMParser = xmldom.DOMParser;
    sWindow.DOMImplementation = xmldom.DOMImplementation;
    sWindow.document = new DOMImplementation().createDocument("http://www.w3.org/1999/xhtml", "html", null);
}
else {
    sWindow = self;
}
function SelectNodesEx(node, xPath) {
    var doc = node.ownerDocument == null ? node : node.ownerDocument;
    var nsResolver = document.createNSResolver(node.ownerDocument == null ? node.documentElement : node.ownerDocument.documentElement);
    var personIterator = doc.evaluate(xPath, node, nsResolver, XPathResult.ANY_TYPE, null);
    var ns = [];
    var n;
    while (n = personIterator.iterateNext()) {
        ns.push(n);
    }
    return ns;
}
var Select = (typeof self !== "undefined") ? SelectNodesEx : xpath;
function Parse(xmlString) {
    xmlString = xmlString
        .replace(/\r\n/g, "\n")
        .replace(/\r/g, "\n");
    return new DOMParser().parseFromString(xmlString, APPLICATION_XML);
}
function Stringify(target) {
    return new XMLSerializer().serializeToString(target);
}
function SelectSingleNode(node, path) {
    var ns = Select(node, path);
    if (ns && ns.length > 0) {
        return ns[0];
    }
    return null;
}
function _SelectNamespaces(node, selectedNodes) {
    if (selectedNodes === void 0) { selectedNodes = {}; }
    if (node && node.nodeType === exports.XmlNodeType.Element) {
        var el = node;
        if (el.namespaceURI && el.namespaceURI !== "http://www.w3.org/XML/1998/namespace" && !selectedNodes[el.prefix || ""]) {
            selectedNodes[el.prefix ? el.prefix : ""] = node.namespaceURI;
        }
        for (var i = 0; i < node.childNodes.length; i++) {
            var childNode = node.childNodes.item(i);
            if (childNode && childNode.nodeType === exports.XmlNodeType.Element) {
                _SelectNamespaces(childNode, selectedNodes);
            }
        }
    }
}
function SelectNamespaces(node) {
    var attrs = {};
    _SelectNamespaces(node, attrs);
    return attrs;
}
function assign$1(target) {
    var sources = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        sources[_i - 1] = arguments[_i];
    }
    var res = arguments[0];
    for (var i = 1; i < arguments.length; i++) {
        var obj = arguments[i];
        for (var prop in obj) {
            if (!obj.hasOwnProperty(prop)) {
                continue;
            }
            res[prop] = obj[prop];
        }
    }
    return res;
}

var XmlBase64Converter = {
    get: function (value) {
        if (value) {
            return Convert.ToBase64(value);
        }
        return void 0;
    },
    set: function (value) {
        return Convert.FromBase64(value);
    },
};
var XmlNumberConverter = {
    get: function (value) {
        if (value) {
            return value.toString();
        }
        return "0";
    },
    set: function (value) {
        return Number(value);
    },
};
var XmlBooleanConverter = {
    get: function (value) {
        if (value) {
            return value.toString();
        }
        return "false";
    },
    set: function (value) {
        if (value && value.toLowerCase() === "true") {
            return true;
        }
        else {
            return false;
        }
    },
};

var DEFAULT_ROOT_NAME = "xml_root";
var XmlObject = (function () {
    function XmlObject() {
        this.prefix = this.GetStatic().prefix || null;
        this.localName = this.GetStatic().localName;
        this.namespaceURI = this.GetStatic().namespaceURI;
    }
    XmlObject.LoadXml = function (param) {
        var xml = new this();
        xml.LoadXml(param);
        return xml;
    };
    XmlObject.GetElement = function (element, name, required) {
        if (required === void 0) { required = true; }
        var xmlNodeList = element.getElementsByTagName(name);
        if (required && xmlNodeList.length === 0) {
            throw new XmlError(exports.XE.ELEMENT_MISSING, name, element.localName);
        }
        return xmlNodeList[0] || null;
    };
    XmlObject.GetAttribute = function (element, attrName, defaultValue, required) {
        if (required === void 0) { required = true; }
        if (element.hasAttribute(attrName)) {
            return element.getAttribute(attrName);
        }
        else {
            if (required) {
                throw new XmlError(exports.XE.ATTRIBUTE_MISSING, attrName, element.localName);
            }
            return defaultValue;
        }
    };
    XmlObject.GetElementById = function (node, idValue) {
        if ((node == null) || (idValue == null)) {
            return null;
        }
        var xel = null;
        if (node.nodeType === exports.XmlNodeType.Document) {
            xel = node.getElementById(idValue);
        }
        if (xel == null) {
            xel = SelectSingleNode(node, "//*[@Id='" + idValue + "']");
            if (xel == null) {
                xel = SelectSingleNode(node, "//*[@ID='" + idValue + "']");
                if (xel == null) {
                    xel = SelectSingleNode(node, "//*[@id='" + idValue + "']");
                }
            }
        }
        return xel;
    };
    XmlObject.CreateDocument = function (root, namespaceUri, prefix) {
        if (root === void 0) { root = DEFAULT_ROOT_NAME; }
        if (namespaceUri === void 0) { namespaceUri = null; }
        if (prefix === void 0) { prefix = null; }
        var namePrefix = "";
        var nsPrefix = "";
        var namespaceUri2 = "";
        if (prefix) {
            namePrefix = prefix + ":";
            nsPrefix = ":" + prefix;
        }
        if (namespaceUri) {
            namespaceUri2 = " xmlns" + nsPrefix + "=\"" + namespaceUri + "\"";
        }
        var name = "" + namePrefix + root;
        var doc = new DOMParser().parseFromString("<" + name + namespaceUri2 + "></" + name + ">", APPLICATION_XML);
        return doc;
    };
    XmlObject.GetChildren = function (node, localName, nameSpace) {
        node = node.documentElement || node;
        var res = [];
        for (var i = 0; i < node.childNodes.length; i++) {
            var child = node.childNodes[i];
            if (child.nodeType === exports.XmlNodeType.Element && child.localName === localName && (child.namespaceURI === nameSpace || !nameSpace)) {
                res.push(child);
            }
        }
        return res;
    };
    XmlObject.GetFirstChild = function (node, localName, nameSpace) {
        node = node.documentElement || node;
        for (var i = 0; i < node.childNodes.length; i++) {
            var child = node.childNodes[i];
            if (child.nodeType === exports.XmlNodeType.Element && child.localName === localName && (child.namespaceURI === nameSpace || !nameSpace)) {
                return child;
            }
        }
        return null;
    };
    XmlObject.GetChild = function (node, localName, nameSpace, required) {
        if (required === void 0) { required = true; }
        for (var i = 0; i < node.childNodes.length; i++) {
            var child = node.childNodes[i];
            if (child.nodeType === exports.XmlNodeType.Element && child.localName === localName && (child.namespaceURI === nameSpace || !nameSpace)) {
                return child;
            }
        }
        if (required) {
            throw new XmlError(exports.XE.ELEMENT_MISSING, localName, node.localName);
        }
        return null;
    };
    Object.defineProperty(XmlObject.prototype, "Element", {
        get: function () {
            return this.element;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XmlObject.prototype, "Prefix", {
        get: function () {
            return this.prefix;
        },
        set: function (value) {
            this.prefix = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XmlObject.prototype, "LocalName", {
        get: function () {
            return this.localName;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XmlObject.prototype, "NamespaceURI", {
        get: function () {
            return this.namespaceURI || null;
        },
        enumerable: true,
        configurable: true
    });
    XmlObject.prototype.HasChanged = function () {
        var self = this.GetStatic();
        if (self.items) {
            for (var key in self.items) {
                if (!self.items.hasOwnProperty(key)) {
                    continue;
                }
                var item = self.items[key];
                var value = this[key];
                if (item.parser && value && value.HasChanged()) {
                    return true;
                }
            }
        }
        return this.element === null;
    };
    XmlObject.prototype.GetXml = function (hard) {
        if (!(hard || this.HasChanged())) {
            return this.element || null;
        }
        var doc = this.CreateDocument();
        var el = this.CreateElement();
        var self = this.GetStatic();
        var localName = this.localName;
        if (self.items) {
            for (var key in self.items) {
                if (!self.items.hasOwnProperty(key)) {
                    continue;
                }
                var parser = this[key];
                var selfItem = self.items[key];
                switch (selfItem.type) {
                    case CONTENT: {
                        var schema = selfItem;
                        var value = (schema.converter) ? schema.converter.get(parser) : parser;
                        if (schema.required && (value === null || value === void 0)) {
                            throw new XmlError(exports.XE.CONTENT_MISSING, localName);
                        }
                        if (schema.defaultValue !== parser || schema.required) {
                            el.textContent = value;
                        }
                        break;
                    }
                    case ATTRIBUTE: {
                        var schema = selfItem;
                        var value = (schema.converter) ? schema.converter.get(parser) : parser;
                        if (schema.required && (value === null || value === void 0)) {
                            throw new XmlError(exports.XE.ATTRIBUTE_MISSING, schema.localName, localName);
                        }
                        if (schema.defaultValue !== parser || schema.required) {
                            if (!schema.namespaceURI) {
                                el.setAttribute(schema.localName, value);
                            }
                            else {
                                el.setAttributeNS(schema.namespaceURI, schema.localName, value);
                            }
                        }
                        break;
                    }
                    case ELEMENT: {
                        var schema = selfItem;
                        var node = null;
                        if (schema.parser) {
                            if ((schema.required && !parser) ||
                                (schema.minOccurs && !parser.Count)) {
                                throw new XmlError(exports.XE.ELEMENT_MISSING, parser.localName, localName);
                            }
                            if (parser) {
                                node = parser.GetXml(parser.element === void 0 && (schema.required || parser.Count));
                            }
                        }
                        else {
                            var value = (schema.converter) ? schema.converter.get(parser) : parser;
                            if (schema.required && value === void 0) {
                                throw new XmlError(exports.XE.ELEMENT_MISSING, schema.localName, localName);
                            }
                            if (parser !== schema.defaultValue || schema.required) {
                                if (!schema.namespaceURI) {
                                    node = doc.createElement("" + (schema.prefix ? schema.prefix + ":" : "") + schema.localName);
                                }
                                else {
                                    node = doc.createElementNS(schema.namespaceURI, "" + (schema.prefix ? schema.prefix + ":" : "") + schema.localName);
                                }
                                node.textContent = value;
                            }
                        }
                        if (node) {
                            if (schema.noRoot) {
                                var els = [];
                                for (var i = 0; i < node.childNodes.length; i++) {
                                    var colNode = node.childNodes.item(i);
                                    if (colNode.nodeType === exports.XmlNodeType.Element) {
                                        els.push(colNode);
                                    }
                                }
                                if (els.length < schema.minOccurs || els.length > schema.maxOccurs) {
                                    throw new XmlError(exports.XE.COLLECTION_LIMIT, parser.localName, self.localName);
                                }
                                els.forEach(function (e) { return el.appendChild(e.cloneNode(true)); });
                            }
                            else if (node.childNodes.length < schema.minOccurs || node.childNodes.length > schema.maxOccurs) {
                                throw new XmlError(exports.XE.COLLECTION_LIMIT, parser.localName, self.localName);
                            }
                            else {
                                el.appendChild(node);
                            }
                        }
                        break;
                    }
                }
            }
        }
        this.OnGetXml(el);
        this.element = el;
        return el;
    };
    XmlObject.prototype.LoadXml = function (param) {
        var element;
        if (typeof param === "string") {
            var doc = Parse(param);
            element = doc.documentElement;
        }
        else {
            element = param;
        }
        if (!element) {
            throw new XmlError(exports.XE.PARAM_REQUIRED, "element");
        }
        var self = this.GetStatic();
        var localName = this.localName;
        if (!((element.localName === localName) && (element.namespaceURI == this.NamespaceURI))) {
            throw new XmlError(exports.XE.ELEMENT_MALFORMED, localName);
        }
        if (self.items) {
            for (var key in self.items) {
                if (!self.items.hasOwnProperty(key)) {
                    continue;
                }
                var selfItem = self.items[key];
                switch (selfItem.type) {
                    case CONTENT: {
                        var schema = selfItem;
                        if (schema.required && !element.textContent) {
                            throw new XmlError(exports.XE.CONTENT_MISSING, localName);
                        }
                        if (!element.textContent) {
                            this[key] = schema.defaultValue;
                        }
                        else {
                            var value = schema.converter ? schema.converter.set(element.textContent) : element.textContent;
                            this[key] = value;
                        }
                        break;
                    }
                    case ATTRIBUTE: {
                        var schema = selfItem;
                        var hasAttribute = void 0;
                        var getAttribute = void 0;
                        if (schema.namespaceURI) {
                            hasAttribute = element.hasAttributeNS.bind(element, schema.namespaceURI, schema.localName);
                            getAttribute = element.getAttributeNS.bind(element, schema.namespaceURI, schema.localName);
                        }
                        else {
                            hasAttribute = element.hasAttribute.bind(element, schema.localName);
                            getAttribute = element.getAttribute.bind(element, schema.localName);
                        }
                        if (schema.required && !hasAttribute()) {
                            throw new XmlError(exports.XE.ATTRIBUTE_MISSING, schema.localName, localName);
                        }
                        if (!hasAttribute()) {
                            this[key] = schema.defaultValue;
                        }
                        else {
                            var value = schema.converter ? schema.converter.set(getAttribute()) : getAttribute();
                            this[key] = value;
                        }
                        break;
                    }
                    case ELEMENT: {
                        var schema = selfItem;
                        if (schema.noRoot) {
                            if (!schema.parser) {
                                throw new XmlError(exports.XE.XML_EXCEPTION, "Schema for '" + schema.localName + "' with flag noRoot must have 'parser'");
                            }
                            var col = new schema.parser();
                            if (!(col instanceof XmlCollection)) {
                                throw new XmlError(exports.XE.XML_EXCEPTION, "Schema for '" + schema.localName + "' with flag noRoot must have 'parser' like instance of XmlCollection");
                            }
                            col.OnLoadXml(element);
                            delete col.element;
                            if (col.Count < schema.minOccurs || col.Count > schema.maxOccurs) {
                                throw new XmlError(exports.XE.COLLECTION_LIMIT, schema.parser.localName, localName);
                            }
                            this[key] = col;
                            continue;
                        }
                        var foundElement = null;
                        for (var i = 0; i < element.childNodes.length; i++) {
                            var node = element.childNodes.item(i);
                            if (node.nodeType !== exports.XmlNodeType.Element) {
                                continue;
                            }
                            var el = node;
                            if (el.localName === schema.localName &&
                                el.namespaceURI == schema.namespaceURI) {
                                foundElement = el;
                                break;
                            }
                        }
                        if (schema.required && !foundElement) {
                            throw new XmlError(exports.XE.ELEMENT_MISSING, schema.parser ? schema.parser.localName : schema.localName, localName);
                        }
                        if (!schema.parser) {
                            if (!foundElement) {
                                this[key] = schema.defaultValue;
                            }
                            else {
                                var value = schema.converter ? schema.converter.set(foundElement.textContent) : foundElement.textContent;
                                this[key] = value;
                            }
                        }
                        else {
                            if (foundElement) {
                                var value = new schema.parser();
                                value.localName = schema.localName;
                                value.namespaceURI = schema.namespaceURI;
                                this[key] = value;
                                value.LoadXml(foundElement);
                            }
                        }
                        break;
                    }
                }
            }
        }
        this.OnLoadXml(element);
        this.prefix = element.prefix || "";
        this.element = element;
    };
    XmlObject.prototype.toString = function () {
        var xml = this.GetXml();
        return xml ? new XMLSerializer().serializeToString(xml) : "";
    };
    XmlObject.prototype.GetElement = function (name, required) {
        if (required === void 0) { required = true; }
        if (!this.element) {
            throw new XmlError(exports.XE.NULL_PARAM, this.localName);
        }
        return XmlObject.GetElement(this.element, name, required);
    };
    XmlObject.prototype.GetChildren = function (localName, nameSpace) {
        if (!this.element) {
            throw new XmlError(exports.XE.NULL_PARAM, this.localName);
        }
        return XmlObject.GetChildren(this.element, localName, nameSpace || this.NamespaceURI || undefined);
    };
    XmlObject.prototype.GetChild = function (localName, required) {
        if (required === void 0) { required = true; }
        if (!this.element) {
            throw new XmlError(exports.XE.NULL_PARAM, this.localName);
        }
        return XmlObject.GetChild(this.element, localName, this.NamespaceURI || undefined, required);
    };
    XmlObject.prototype.GetFirstChild = function (localName, namespace) {
        if (!this.element) {
            throw new XmlError(exports.XE.NULL_PARAM, this.localName);
        }
        return XmlObject.GetFirstChild(this.element, localName, namespace);
    };
    XmlObject.prototype.GetAttribute = function (name, defaultValue, required) {
        if (required === void 0) { required = true; }
        if (!this.element) {
            throw new XmlError(exports.XE.NULL_PARAM, this.localName);
        }
        return XmlObject.GetAttribute(this.element, name, defaultValue, required);
    };
    XmlObject.prototype.IsEmpty = function () {
        return this.Element === void 0;
    };
    XmlObject.prototype.OnLoadXml = function (element) {
    };
    XmlObject.prototype.GetStatic = function () {
        return this.constructor;
    };
    XmlObject.prototype.GetPrefix = function () {
        return (this.Prefix) ? this.prefix + ":" : "";
    };
    XmlObject.prototype.OnGetXml = function (element) {
    };
    XmlObject.prototype.CreateElement = function (document, localName, namespaceUri, prefix) {
        if (namespaceUri === void 0) { namespaceUri = null; }
        if (prefix === void 0) { prefix = null; }
        if (!document) {
            document = this.CreateDocument();
        }
        localName = localName || this.localName;
        namespaceUri = namespaceUri || this.NamespaceURI;
        prefix = prefix || this.prefix;
        var xn = document.createElementNS(this.NamespaceURI, (prefix ? prefix + ":" : "") + localName);
        document.importNode(xn, true);
        return xn;
    };
    XmlObject.prototype.CreateDocument = function () {
        return XmlObject.CreateDocument(this.localName, this.NamespaceURI, this.Prefix);
    };
    return XmlObject;
}());

var XmlCollection = (function (_super) {
    __extends(XmlCollection, _super);
    function XmlCollection() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.items = new Array();
        return _this;
    }
    XmlCollection.prototype.HasChanged = function () {
        var res = _super.prototype.HasChanged.call(this);
        var changed = this.Some(function (item) { return item.HasChanged(); });
        return res || changed;
    };
    Object.defineProperty(XmlCollection.prototype, "Count", {
        get: function () {
            return this.items.length;
        },
        enumerable: true,
        configurable: true
    });
    XmlCollection.prototype.Item = function (index) {
        return this.items[index] || null;
    };
    XmlCollection.prototype.Add = function (item) {
        this.items.push(item);
        this.element = null;
    };
    XmlCollection.prototype.Pop = function () {
        this.element = null;
        return this.items.pop();
    };
    XmlCollection.prototype.RemoveAt = function (index) {
        this.items = this.items.filter(function (item, index2) { return index2 !== index; });
        this.element = null;
    };
    XmlCollection.prototype.Clear = function () {
        this.items = new Array();
        this.element = null;
    };
    XmlCollection.prototype.GetIterator = function () {
        return this.items;
    };
    XmlCollection.prototype.ForEach = function (cb) {
        this.GetIterator().forEach(cb);
    };
    XmlCollection.prototype.Map = function (cb) {
        return new Collection(this.GetIterator().map(cb));
    };
    XmlCollection.prototype.Filter = function (cb) {
        return new Collection(this.GetIterator().filter(cb));
    };
    XmlCollection.prototype.Sort = function (cb) {
        return new Collection(this.GetIterator().sort(cb));
    };
    XmlCollection.prototype.Every = function (cb) {
        return this.GetIterator().every(cb);
    };
    XmlCollection.prototype.Some = function (cb) {
        return this.GetIterator().some(cb);
    };
    XmlCollection.prototype.IsEmpty = function () {
        return this.Count === 0;
    };
    XmlCollection.prototype.OnGetXml = function (element) {
        for (var _i = 0, _a = this.GetIterator(); _i < _a.length; _i++) {
            var item = _a[_i];
            var el = item.GetXml();
            if (el) {
                element.appendChild(el);
            }
        }
    };
    XmlCollection.prototype.OnLoadXml = function (element) {
        var self = this.GetStatic();
        if (!self.parser) {
            throw new XmlError(exports.XE.XML_EXCEPTION, self.localName + " doesn't have required 'parser' in @XmlElement");
        }
        for (var i = 0; i < element.childNodes.length; i++) {
            var node = element.childNodes.item(i);
            if (!(node.nodeType === exports.XmlNodeType.Element &&
                node.localName === self.parser.localName &&
                node.namespaceURI == self.namespaceURI)) {
                continue;
            }
            var el = node;
            var item = new self.parser();
            item.LoadXml(el);
            this.Add(item);
        }
    };
    return XmlCollection;
}(XmlObject));

var NamespaceManager = (function (_super) {
    __extends(NamespaceManager, _super);
    function NamespaceManager() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NamespaceManager.prototype.Add = function (item) {
        item.prefix = item.prefix || "";
        item.namespace = item.namespace || "";
        _super.prototype.Add.call(this, item);
    };
    NamespaceManager.prototype.GetPrefix = function (prefix, start) {
        if (start === void 0) { start = this.Count - 1; }
        var lim = this.Count - 1;
        prefix = prefix || "";
        if (start > lim) {
            start = lim;
        }
        for (var i = start; i >= 0; i--) {
            var item = this.items[i];
            if (item.prefix === prefix) {
                return item;
            }
        }
        return null;
    };
    NamespaceManager.prototype.GetNamespace = function (namespaceUrl, start) {
        if (start === void 0) { start = this.Count - 1; }
        var lim = this.Count - 1;
        namespaceUrl = namespaceUrl || "";
        if (start > lim) {
            start = lim;
        }
        for (var i = start; i >= 0; i--) {
            var item = this.items[i];
            if (item.namespace === namespaceUrl) {
                return item;
            }
        }
        return null;
    };
    return NamespaceManager;
}(Collection));

exports.XmlElement = XmlElement;
exports.XmlChildElement = XmlChildElement;
exports.XmlAttribute = XmlAttribute;
exports.XmlContent = XmlContent;
exports.Collection = Collection;
exports.Convert = Convert;
exports.Select = Select;
exports.Parse = Parse;
exports.Stringify = Stringify;
exports.SelectSingleNode = SelectSingleNode;
exports.SelectNamespaces = SelectNamespaces;
exports.assign = assign$1;
exports.XmlBase64Converter = XmlBase64Converter;
exports.XmlNumberConverter = XmlNumberConverter;
exports.XmlBooleanConverter = XmlBooleanConverter;
exports.XmlError = XmlError;
exports.APPLICATION_XML = APPLICATION_XML;
exports.DEFAULT_PREFIX = DEFAULT_PREFIX;
exports.DEFAULT_NAMESPACE_URI = DEFAULT_NAMESPACE_URI;
exports.XmlCollection = XmlCollection;
exports.XmlObject = XmlObject;
exports.NamespaceManager = NamespaceManager;

Object.defineProperty(exports, '__esModule', { value: true });

})));
